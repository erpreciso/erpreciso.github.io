---
title: "Global Terrorism Database: un'analisi esplorativa per familiarizzare con il database"
output:
  github_document:
    toc: true
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
```

# Introduzione

Il GTD e' un database open source contenente informazioni su eventi di terrorismo dal 1970 al 2015. In queste pagine mi limito all'esplorazione delle informazioni contenute come preparazione per una futura analisi.

Riporto la descrizione dettagliata del database dalla pagina introduttiva presente nel portale web [http://start.umd.edu/gtd/about/](http://start.umd.edu/gtd/about/)

>Overview of the GTD
>
>The Global Terrorism Database (GTD) is an open-source database including information on terrorist events around the world from 1970 through 2015 (with additional annual updates planned for the future). Unlike many other event databases, the GTD includes systematic data on domestic as well as transnational and international terrorist incidents that have occurred during this time period and now includes more than 150,000 cases. For each GTD incident, information is available on the date and location of the incident, the weapons used and nature of the target, the number of casualties, and--when identifiable--the group or individual responsible.
>
>Statistical information contained in the Global Terrorism Database is based on reports from a variety of open media sources. Information is not added to the GTD unless and until we have determined the sources are credible. Users should not infer any additional actions or results beyond what is presented in a GTD entry and specifically, users should not infer an individual associated with a particular incident was tried and convicted of terrorism or any other criminal offense. If new documentation about an event becomes available, an entry may be modified, as necessary and appropriate.
>
>The National Consortium for the Study of Terrorism and Responses to Terrorism (START) makes the GTD available via this online interface in an effort to increase understanding of terrorist violence so that it can be more readily studied and defeated.
    
# Preparazione dell'ambiente di lavoro

```{r prepare-workspace}
library(tidyverse)
db_original_path <- "~/Downloads/globalterrorismdb_0616dist.csv"
```

# Preparazione dei dati

Scarico i dati da Kaggle dalla pagina [https://www.kaggle.com/START-UMD/gtd](https://www.kaggle.com/START-UMD/gtd) e li importo in R tramite il pacchetto `readr`. Alcune variabili sono automaticamente lette come formato `integer` (`readr` deriva i formati colonne dalle prime 1000 osservazioni) ma cio non e' corretto e quindi fornisco manualmente i formati, almeno per queste osservazioni errate.

```{r read-data}
db <-
  readr::read_csv(db_original_path,
                  col_types = readr::cols(nkill = readr::col_double(),
                                          nwound = readr::col_double(),
                                          propvalue = readr::col_double(),
                                          nhours = readr::col_double(),
                                          nperpcap = readr::col_double(),
                                          nhostkid = readr::col_double(),
                                          nreleased = readr::col_double(),
                                          nkillter = readr::col_double(),
                                          nkillus = readr::col_double(),
                                          nwoundus = readr::col_double(),
                                          ransomamt = readr::col_double(),
                                          nwoundte = readr::col_double(),
                                          ransompaid = readr::col_double()))
```

# Esplorazione

## Dimensioni del dataset

Numero di righe e colonne

```{r}
db %>% dim()
```

## Nomi e struttura delle variabili

```{r}
dplyr::glimpse(db)
```

I nomi delle variabili sono in un formato consistente, non necessitano di revisione e modifica.

Le variabili presentano delle classi adeguate ai dati che rappresentano; tutte le specifiche sono nel [codebook](http://www.start.umd.edu/gtd/downloads/Codebook.pdf).


## Uno sguardo ai dati

### Caso dell'Undici Settembre

```{r nine-eleven}
db %>% 
  filter(iyear == 2001,
         imonth == 9,
         iday == 11,
         country_txt == "United States") %>% 
  print.data.frame
```

### Caso della strage alla stazione di Bologna

```{r}
db %>% 
  filter(iyear == 1980,
         imonth == 8,
         iday == 2,
         country_txt == "Italy") %>%
  print.data.frame
```


## Conversione nel formato Table Data Frame

Un formato conveniente per essere visualizzato in quanto limita la stampa a schermo ad un numero di righe e colonne adatto ad una console.

```{r}
db <- db %>% tbl_df()
```

## Tipologie delle variabili

Suddivido le variabili a seconda dei vari tipi (testo, numero) per successive analisi differenziate in base a questo.

```{r}
num_vars <- names(db)[sapply(db, class) %in% c("numeric", "integer")]
text_vars <- names(db)[sapply(db, class) == "character"]

# controllo che tutte le variabili sono categorizzate
c(num_vars, text_vars) %>% length() == length(names(db))
```


## Approfondimento su alcune variabili


### Geolocalizzazioni mancanti

```{r}
db %>% distinct(region_txt)
```

Ci sono `r sum(is.na(db$latitude))` geolocalizzazioni mancanti, ma la regione (suddivisione geografica piu' vasta) e lo stato sono sempre popolati.

```{r}
db %>% 
  filter(is.na(latitude)) %>% 
  ggplot(aes(x = iyear, y = region_txt)) +
  geom_jitter() + 
  labs(title = "Geolocalizzazioni mancanti per regione",
       x = "Anno",
       y = "Regione")
```

### Variabile "numero persone uccise" `nkill` mancante

```{r}
db %>% 
  filter(is.na(nkill)) %>% 
  ggplot(aes(x = iyear, y = weaptype1_txt)) +
  geom_jitter() + 
  labs(x = "Anno",
       y = "Tipo di arma",
       title = "Informazione mancante sul numero delle persone uccise")
```


### Creazione variabile "data" `date`

Dato che una variabile "data" non esiste, la creo partendo da anno, mese e giorno.

```{r}
db <- db %>% 
  mutate(date = ISOdate(iyear, imonth, iday))
date_vars <- "date" # tipo di variabili
db %>% 
  ggplot(aes(x = date)) +
  stat_count() +
  theme_minimal() +
  labs(title = "Distribuzione degli attacchi per data",
       x = "Giorno",
       y = "Conteggio")
```

## Gruppi di variabili

Da codebook, posso dividere le variabili in 9 gruppi:

1. ID e variabili temporali: GTD ID and Date
2. Informazioni generali sull'evento: Incident Information
3. Localizzazione: Incident Location
4. Tipo di attacco: Attack Information
5. Armi: Weapon Information
6. Tipo di obiettivo e vittime: Target/Victim Information
7. Informazioni sull'attentatore: Perpetrator Information
8. Vittime e conseguenze: Casualties and Consequences
9. Altre informazioni e provenienza: Additional Information and Sources

```{r var-groups}
gtd_id_date <-
  c("eventid",
    "iyear",
    "imonth",
    "iday",
    "approxdate",
    "extended",
    "resolution")
incident_info <-
  c(
    "summary",
    "crit1",
    "crit2",
    "crit3",
    "doubtterr",
    "alternative_txt",
    "multiple",
    "related"
  )
incident_location <-
  c(
    "country_txt",
    "region_txt",
    "provstate",
    "city",
    "vicinity",
    "location",
    "latitude",
    "longitude",
    "specificity"
  )
attack_info <-
  c("attacktype1_txt",
    "attacktype2_txt",
    "attacktype3_txt",
    "success",
    "suicide")
weapon_info <-
  c("weaptype1_txt",
    "weaptype2_txt",
    "weaptype3_txt",
    "weaptype4_txt",
    "weapdetail")
target_info <-
  c(
    "targtype1_txt",
    "targsubtype1_txt",
    "corp1",
    "target1",
    "natlty1_txt",
    "targtype2_txt",
    "targsubtype2_txt",
    "corp2",
    "target2",
    "natlty2_txt",
    "targtype3_txt",
    "targsubtype3_txt",
    "corp3",
    "target3",
    "natlty3_txt"
  )
perpetrator_info <-
  c(
    "gname",
    "gsubname",
    "gname2",
    "gsubname2",
    "gname3",
    "gsubname3",
    "guncertain1",
    "guncertain2",
    "guncertain3",
    "nperps",
    "nperpcap",
    "claimed",
    "claimmode_txt",
    "compclaim",
    "claim2",
    "claimmode2",
    "claim3",
    "claimmode3",
    "motive"
  )
causalties <-
  c(
    "nkill",
    "nkillter",
    "nwound",
    "nwoundte",
    "ishostkid",
    "nhostkid",
    "nhours",
    "ndays",
    "divert",
    "kidhijcountry",
    "hostkidoutcome_txt",
    "nreleased"
  )
consequences <-
  c(
    "property",
    "propextent_txt",
    "propvalue",
    "propcomment",
    "ransom",
    "ransompaid",
    "ransomnote"
  )
```


# Analisi per gruppi di variabili

## ID e variabili temporali

Il primo gruppo di variabili comprende l'ID univoco dell'evento, e la data in cui esso e' avvenuto. Di seguito una semplice distribuzione degli eventi per anno.
```{r id-and-date}
db %>% 
  select_(.dots = gtd_id_date) %>% 
  ggplot(aes(x = iyear)) +
  stat_count() +
  labs(title = "Numero di eventi per anno",
       x = "Anno",
       y = "Numero di eventi") +
  scale_y_continuous(labels = scales::comma) +
  theme_minimal()
```

Come riportato nel codebook, l'anno 1993 non contiene dati.


## Informazioni generali sull'evento

Il secondo gruppo di variabili contiene informazioni sulla classificazione dell'evento. In particolare, analizzo la distribuzione dei criteri di inclusione:

* **Criterio 1**: l'atto deve essere finalizzato al raggiungimento di un obiettivo politico, economico, religioso o sociale. Il criterio non e` soddisfatto se il perpetratore agisce per puro profitto personale.

* **Criterio 2**: deve esserci evidenza di un'intenzione di sottomettere, intimidare o consegnare un messaggio ad un pubblico piu` grande delle vittime dirette. Manifestazioni di questo possono essere dichiarazioni prima o dopo l'attacco, o scelta particolare di vittime, armi e strategie di attacco.

* **Criterio 3**: l'azione deve essere considerata come un attacco non convenzionale a civili al di fuori delle convenzioni di guerra, come ad esempio la convenzione di Ginevra del 1949.


```{r incident-info}
freq <- db %>% 
  select_(.dots = incident_info) %>% 
  select(crit1, crit2, crit3) %>% 
  group_by(crit1, crit2, crit3) %>% 
  count() %>% 
  ungroup()
area1 <- freq %>% filter(crit1 == 1) %>% summarize(a = sum(n))
area2 <- freq %>% filter(crit2 == 1) %>% summarize(a = sum(n))
area3 <- freq %>% filter(crit3 == 1) %>% summarize(a = sum(n))
n12 <- freq %>%
  filter(crit1 == 1, crit2 == 1) %>%
  summarize(a = sum(n))
n23 <- freq %>%
  filter(crit2 == 1, crit3 == 1) %>%
  summarize(a = sum(n))
n13 <- freq %>%
  filter(crit1 == 1, crit3 == 1) %>%
  summarize(a = sum(n))
n123 <- freq %>%
  filter(crit1 == 1, crit2 == 1, crit3 == 1) %>%
  summarize(a = sum(n))
vplot <- VennDiagram::draw.triple.venn(area1[[1]],
                              area2[[1]],
                              area3[[1]],
                              n12[[1]],
                              n23[[1]],
                              n13[[1]],
                              n123[[1]],
                              category = c("Criterio 1",
                                           "Criterio 2",
                                           "Criterio 3"),
                              euler.d = TRUE,
                              scaled = TRUE,
                              lwd = c(1, 1, 1),
                              fill = c("blue", "red", "green"))
grid::grid.draw(vplot)
```

## Localizzazione

Il 90% degli avvenimenti accade in 37 stati. Qui riporto la tabella di frequenza relativa a questi, ed una mappa di tipo choropleth comprendente invece tutto il mondo.

### Mappa di frequenza

```{r regions-freq}
db %>% 
  select(Regione = region_txt) %>% 
  sapply(table)
```

```{r incident-location-freq-table}
db %>% 
  select_(.dots = incident_location) %>% 
  group_by(country_txt) %>% 
  count() %>% 
  arrange(desc(n)) %>% 
  mutate(freq = prop.table(n), cumul = cumsum(freq)) %>% 
  filter(cumul < 0.9) %>% 
  select(Paese = country_txt, n, cumul) %>% 
  mutate(`Percentuale cumulata` = scales::percent(cumul),
         Conteggio = scales::comma(n)) %>% 
  select(-cumul, -n)

```


### Choropleth

Mappa choropleth che mostra una scala di colori in base al numero di eventi accaduti per ogni stato.

```{r incident-location-choropleth}
library(maps)
world_map <- map_data("world")
attacks_by_country <- db %>% 
  select_(.dots = incident_location) %>% 
  group_by(country_txt) %>% 
  count() %>% 
  rename(country = country_txt)

attacks_by_country %>% 
  ggplot(aes(map_id = country)) +
  geom_map(aes(fill = n), map = world_map) +
  expand_limits(x = world_map$long, y = world_map$lat) +
  labs(title = "Numero di attacchi per paese")
```

Il risultato e' pero' parziale in quanto dei nomi di nazioni non sono consistenti tra il database e la mappa. Ad esempio, nella mappa gli Stati Uniti sono etichettati come "USA", mentre nel database sono "United States".

```{r not-matching-countries}
countries <- world_map %>% 
  select(country = region) %>% 
  distinct(country)

attacks_by_country %>% 
  anti_join(countries, by = "country") %>% 
  arrange(desc(n))
```

Pulisco manualmente due casi.

```{r choropleth-cleaned}
attacks_by_country[attacks_by_country$country == "United States", "country"] <- "USA"
attacks_by_country[attacks_by_country$country == "United Kingdom", "country"] <- "UK"

attacks_by_country %>% 
  ggplot(aes(map_id = country)) +
  geom_map(aes(fill = n), map = world_map) +
  expand_limits(x = world_map$long, y = world_map$lat) +
  labs(title = "Numero di attachi per paese (dati parzialmente puliti)")

```

Meglio, ma ci sono dei limiti dovuti alla natura del dataset: alcuni stati non esistono piu, come ad esempio la Germania dell'Est o la Yugoslavia. Riportare questi dati nelle attuali nazioni potrebbe essere impreciso, o addirittura errato.


### Grafico mediante `ggmap`

Usando la geolocalizzazione si possono ottenere risultati piu precisi in quanto non esiste il vincolo dei confini nazionali nel definire le mappe.

Di seguito, un estratto del dato riguardante l'Europa.

```{r ggmap-europe, message=FALSE}
library(ggmap)
europe <- ggmap::get_map(location = "Berlin", zoom = 4, maptype = "terrain")
geo <- db %>% 
  select_(.dots = incident_location) %>% 
  filter(region_txt == "Western Europe" | region_txt == "Eastern Europe") %>% 
  filter(!is.na(latitude) & !is.na(longitude)) %>% 
  group_by(latitude, longitude) %>% 
  count() 
ggmap::ggmap(europe, extent = "panel") +
  geom_point(aes(x = longitude,
                 y = latitude,
                 size = n,
                 alpha = n), data = geo,
             colour = "red") +
  labs(title = "Geolocalizzazione degli attacchi in Europa")

```

```{r ggmap-2}
geo2 <- db %>% 
  select_(.dots = incident_location) %>% 
  filter(region_txt == "Western Europe" | region_txt == "Eastern Europe") %>% 
  filter(!is.na(latitude) & !is.na(longitude))
ggmap::ggmap(europe, extent = "panel") +
  stat_density2d(aes(x = longitude,
                     y = latitude,
                     fill = ..level..,
                     alpha = ..level..),
             size = 2,
             bins = 4,
             geom = "polygon",
             data = geo2) +
  labs(title = "Densita' degli attacchi in Europa")
```

In Europa, gli eventi sono in numero limitato e molto sparsi geograficamente. Ripeto l'esercizio in Israele.

```{r ggmap-middleeast, message=FALSE}
me <- ggmap::get_map(location = "Jerusalem", zoom = 9, maptype = "terrain")
geo3 <- db %>% 
  select_(.dots = incident_location) %>% 
  filter(!is.na(latitude) & !is.na(longitude)) %>% 
  filter(latitude > 31.1 ,
           latitude < 32.5 ,
           longitude > 34.4 ,
           longitude < 36) 
ggmap::ggmap(me, extent = "device", legend = "topleft") +
  stat_density2d(aes(x = longitude,
                     y = latitude,
                     fill = ..level..,
                     alpha = ..level..),
             # size = 2,
             bins = 15,
             geom = "polygon",
             data = geo3) +
  scale_fill_gradient(low = "black",
                      high = "red") +
  labs(title = "Densita' degli attacchi in Israele")

```

Sull'uso del pacchetto `ggmap`, vedere:
> D. Kahle and H. Wickham. ggmap: Spatial Visualization with ggplot2. The R Journal, 5(1), 144-161. URL
> [http://journal.r-project.org/archive/2013-1/kahle-wickham.pdf](http://journal.r-project.org/archive/2013-1/kahle-wickham.pdf)

## Tipo di attacco

```{r}
db %>% 
  select_(.dots = attack_info) %>% 
  select(`Tipo di attacco` = attacktype1_txt) %>% 
  sapply(table)
```

### Attacco suicida?

```{r}
db %>% 
  select(suicide) %>% 
  mutate(suicide = ifelse(suicide == 1, "vero", "falso")) %>% 
  table
```

```{r unordered-attacktype-bars}
db %>% 
  select(suicide, attacktype1_txt) %>% 
  mutate(suicide = suicide == 1) %>% 
  ggplot(aes(x = attacktype1_txt)) +
  geom_bar(aes(fill = suicide)) +
  coord_flip() + 
  theme_minimal() + 
  labs(x = "Tipo di attacco",
       y = "Conteggio",
       title = "Conteggi dei tipi di attacco, con evidenza sul suicidio")
```

Riordino le barre per migliore visualizzazione.

```{r ordered-attacktype-bars}
levs <- db %>%
  select(attacktype1_txt) %>% 
  group_by(attacktype1_txt) %>% 
  count() %>% 
  arrange(n)

db %>% 
  select(suicide, attacktype1_txt) %>% 
  mutate(suicide = suicide == 1) %>% 
  ggplot(aes(x = factor(attacktype1_txt, levels = levs[[1]]))) +
  geom_bar(aes(fill = suicide)) +
  coord_flip() + 
  theme_minimal() + 
  scale_y_continuous(labels = scales::comma) +
  labs(x = "Tipo di attacco",
       y = "Count",
       title = "Conteggi dei tipi di attacco, con evidenza sul suicidio")
```

## Armi

Questa sezione include informazioni sul tipo di arma utilizzata.

```{r}
weapon_info
```

Ci sono quattro diversi livelli di informazione in base alla macrotipologia (`weaptype`) ed un campo di dettaglio (`weapdetail`).

```{r}
sapply(weapon_info, function(x) distinct_(db, x) %>% nrow())
```

Dato che il livello piu' dettagliato ha un conteggio troppo elevato, mostrero i livelli solo per ii campi della gerarchia.

```{r}
sapply(weapon_info[grepl("weaptype", weapon_info)], function(x) distinct_(db, x))
```

Ora un grafico per mostrare il numero di attentati in base all'arma utilizzata.

```{r weapon-info}
levels_weapons <- db %>%
  select(weaptype1_txt) %>% 
  group_by(weaptype1_txt) %>% 
  count() %>% 
  arrange(n) %>% 
  mutate(weaptype1_txt = ifelse(grepl("Vehicle", weaptype1_txt),
                                "Vehicle",
                                weaptype1_txt))

db %>% 
  select(weaptype1_txt) %>% 
  mutate(weaptype1_txt = ifelse(grepl("Vehicle", weaptype1_txt),
                                "Vehicle",
                                weaptype1_txt)) %>% 
  ggplot(aes(x = factor(weaptype1_txt, levels = levels_weapons[[1]]))) +
  geom_bar() +
  coord_flip() + 
  theme_minimal() + 
  scale_y_continuous(labels = scales::comma) +
  labs(x = "Tipo di arma",
       y = "Conteggio",
       title = "Conteggio dei tipi di arma")
```

## Tipo di obiettivo e vittime
```{r target-info}
db %>% 
  select_(.dots = target_info)
```

Prima uno sguardo ai conteggi per ogni variabile.

```{r}
sapply(target_info, function(x) distinct_(db, x) %>% nrow())
```

Ora uno sguardo ai livelli dei target types per capire cosa riportare graficamente.
```{r}
sapply(target_info[grepl("targtype", target_info)], function(x) distinct_(db, x))
```

### Grafico per target types

Creo un solo grafico per la suddivisione del target di livello piu' elevato.

```{r target1-info-graph}
levels_target <- db %>%
  select(targtype1_txt) %>% 
  group_by(targtype1_txt) %>% 
  count() %>% 
  arrange(n)

db %>% 
  select(targtype1_txt) %>% 
  ggplot(aes(x = factor(targtype1_txt, levels = levels_target[[1]]))) +
  geom_bar() +
  coord_flip() + 
  theme_minimal() + 
  scale_y_continuous(labels = scales::comma) +
  labs(x = "Tipo di obiettivo 1",
       y = "Conteggio",
       title = "Conteggio dei tipi di obiettivo")
```



### Nazionalita della vittima

```{r}
db %>% 
  filter(!is.na(natlty1_txt)) %>%
  group_by(natlty1_txt) %>%
  count() %>% 
  arrange(desc(n)) %>%
  mutate(freq = prop.table(n),
         cumul = cumsum(freq)) %>%
  filter(cumul < 0.8) %>%
  arrange(desc(cumul)) %>%

  ggplot(aes(x = reorder(natlty1_txt, n), y = n)) +
  geom_point() +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma) +
  coord_flip() +
  labs(x = "Nazionalita'",
       y = "Numero di persone uccise",
       title = "Numero di persone uccise per nazionalita'")
```

## Informazioni sull'attentatore

```{r perpetr-info}
db %>% 
  select_(.dots = perpetrator_info) %>% 
  glimpse()
```

Queste sembrano tutte variabili con un elevato numero di livelli per poter essere visualizzate. Verranno usate dopo per analisi multivariate.

```{r}
db %>% 
  select(gname) %>% 
  distinct() %>% 
  nrow()
```

## Vittime e conseguenze

```{r}
causalties
```

### Densita' degli attacchi in base al numero di persone uccise

```{r}
db %>% 
  ggplot(aes(x = nkill)) +
  geom_density() + 
  theme_minimal()
```

### Conseguenze economiche

Uno sguardo alle variabili.

```{r}
db %>% 
  select_(.dots = consequences) %>% 
  glimpse()
```

```{r}
db %>% 
  select_(.dots = consequences) %>% 
  summary()
```

```{r}
db %>% 
  ggplot(aes(x = propextent_txt)) +
  geom_bar() +
  coord_flip() +
  theme_minimal() +
  labs(x = "Danni alle proprieta'",
       y = "Conteggio",
       title = "Conteggi delle categorie di danni alle proprieta'")
```


# Alcuni esempi di analisi multivariate

## Paese con il piu elevato numero di vittime

```{r}
db %>% 
  filter(!is.na(nkill)) %>%                # remove all NAs
  select(country_txt, nkill) %>%           # select relevant vars
  group_by(country_txt) %>%                # group by country
  summarise(nkill_tot = sum(nkill)) %>%    # create a column with sum by country
  arrange(desc(nkill_tot)) %>%             # sort descending by death by country
  mutate(freq = prop.table(nkill_tot),     # create share by country, 
         cumul = cumsum(freq)) %>%         # create cumulated share
  filter(cumul < 0.8) %>%                  # keep only countries with 80% of total death
  arrange(desc(cumul)) %>%                 # inverse rank

  ggplot(aes(x = reorder(country_txt, nkill_tot), y = nkill_tot)) +
  geom_point() +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma) +
  coord_flip() +
  labs(x = "Paese",
       y = "Numero di vittime",
       title = "Vittime per paese")
```


## Nazionalita dei morti per paese dove l'attacco e' avvenuto

```{r}
deadliest_countries <- db %>% 
  filter(!is.na(country_txt),
         !is.na(nkill)) %>%
  group_by(country_txt) %>%
  # count() %>% 
  summarise(n = sum(nkill)) %>% 
  arrange(desc(n)) %>%
  mutate(freq = prop.table(n),
         cumul = cumsum(freq)) %>%
  filter(cumul < 0.8) %>% 
  arrange(n)

deadliest_nationalities <- db %>% 
  filter(!is.na(natlty1_txt),
         !is.na(nkill)) %>%
  group_by(natlty1_txt) %>%
  # count() %>% 
  summarise(n = sum(nkill)) %>% 
  arrange(desc(n)) %>%
  mutate(freq = prop.table(n),
         cumul = cumsum(freq)) %>%
  filter(cumul < 0.8) %>% 
  arrange(n)

db %>% 
  filter(country_txt %in% deadliest_countries[,1][[1]],
         natlty1_txt %in% deadliest_nationalities[,1][[1]]) %>% 
  group_by(country_txt, natlty1_txt) %>% 
  count() %>% 
  rename(Paese = country_txt,
         Provenienza = natlty1_txt) %>% 
  ggplot(aes(x = factor(Paese, levels = deadliest_countries[,1][[1]]),
             y = factor(Provenienza, levels = deadliest_nationalities[,1][[1]]))) +
  geom_point(aes(size = n)) +
  theme_minimal() +
  theme(axis.text.x=element_text(angle = 90)) +
  labs(x = "Paese",
       y = "Nazionalita'",
       title = "Nazionalita' dei coinvolti in un evento in base al paese di accadimento")
```


## Evento col piu' elevato numero di vittime

```{r deadliest}
db %>%
  filter(nkill == max(nkill, na.rm = TRUE)) %>%
  select(nkill, summary) %>% 
  knitr::kable()
```


## Eventi avvenuti in Italia

```{r italian-events-by-year}
db %>% 
  filter(country_txt == "Italy") %>% 
  ggplot(aes(x = iyear)) +
  stat_count() +
  labs(title = "Eventi accaduti in Italia per anno",
       y = "Numero di attacchi terroristici",
       x = "Anno") +
  theme_minimal()
```
